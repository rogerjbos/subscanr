---
title: "Substrate blockchain analysis in R"
author: "Roger J. Bos"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Substrate blockchain analysis in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignettes demonstrates the functionality of the *subscanr* package that facilitates substrate blockchain analysis in R.  By substrate we are referring to the Polkadot / Kusama (DotSama) ecosystem, which could include up to 200 different parachains.  

The package provides an interface into three different indexing services in the DotSama ecosystem, along with a bonus section showing how to access on-chain data using Python code in R:

- [Subscan](https://www.subscan.io/)
- [Sub Query](https://subquery.network/)
- [Polkaholic](https://polkaholic.io/#chains)
- [Python Substrate Interface](https://github.com/polkascan/py-substrate-interface)

## Installation

You can install the `subscanr` package using devtools (or remotes) as follows:

```{r, eval = FALSE}
library(devtools)
install_github("rogerjbos/subscanr")
```

Once installed, you can load the package.  The package comes with a number of functions which are detailed below, and it also comes with a few objects and helper functions.  I won't cover all of them, but the `tokens` object is useful because it shows the number of decimal places used for each token.  This object is update manually so it may be always be as up-to-date as it should be!

```{r}
library(subscanr)
tokens
```

## Subscan

Subscan extracts blockchain data from all the available parachains and stores the data in its own database that users can access via their (free) [API](https://support.subscan.io/#introduction).  You have to request a key [here](https://pro.subscan.io/login).  I will show some examples of pulling data from the Subscan API below, but if you have any questions, the best place to ask them is in their [maxtrix site](https://app.element.io/#/room/#subscan:matrix.org).

Subscan currently covers `r nrow(endpoints)` different chains, which are stored in the `endpoints` variable.  You can use the get_endpoint() function to get the host address:

```{r}
head(subscanr::endpoints)
get_endpoint("Acala")
```

The primary function is `get_subscan_events`, which we will call using the `extract = FALSE` parameter.  The functions returns two objects.  The `core_data` object lists the general details of each requested event, such as the block number, extrinsic_hash, and timestamp.  The `params` object contains the actual details on the event, but it is in JSON format so it is more difficult to read.

```{r}
tmp <- get_subscan_events(nobs = 10, network = 'Karura', module = 'dex', call = 'Swap', extract = FALSE)

# First few lines of the core_data
head(tmp$core_data)

# Parameters for the first event
tmp$params[1]
```
The `get_subscan_events` function can be called for any endpoint, but the format of the `params` object will be different for every module and chain.  My works involves the `Acala` and `Karura` chains, so I have coded an `extract` function to re-format the JSON output and add it to the `core_data` object, but this has only been implemented for `Acala` and `Karura`.  If you view the source code you can see how I extract the data and modify that for the chain you are interested.  

The default value of the `extract` parameter is TRUE, so if you call the function again without that parameter, you will see the new `core_data` object, which has been augmented with the JSON data extracted from the `params` column.

```{r}
tmp <- get_subscan_events(nobs = 10, network = 'Karura', module = 'dex', call = 'Swap')

# First few lines of the core_data
head(tmp$core_data)
```

The Subscan API limits each call to 100 rows of data, so if you set `nobs` to greater than 100 the function will use pagination to make multiple calls and aggregate the data, waiting a few seconds every few calls so as to not exceed the API limit for free data.  If you leave the `module` and / or `call` parameters empty the function will return all blockchain events.  That will give you an idea of what options are available for a specific chain so you can specify them and narrow your search.

```{r}
tmp <- get_subscan_events(nobs = 300, network = 'Karura', module = '', call = '', extract = FALSE)

# Module and event types returned for the specified chain
unique(tmp$core_data$module_id)
unique(tmp$core_data$event_id)
```

There are many other functions you can run.  To save space I won't list the output of all of them, but I will list them below so you can try them out on your own.

```{r, eval = FALSE}
get_subscan_token()
get_subscan_token(network = 'Acala')
get_subscan_accounts(network = 'Acala')
get_subscan_account_tokens(network = 'Acala', addr = '23M5ttkmR6Kco5p3LFGKMpMv4zvLkKdUQWW1wGGoV8zDX3am')
get_subscan_metadata(network = 'Acala')
get_subscan_extrinsic(extrinsic = '398539-2')
get_subscan_price()
get_subscan_price_history(network = 'Darwinia', start = '2021-11-01', end = '2021-11-02')
get_subscan_currencies('Polkadot')
get_subscan_price_converter(network = 'Polkadot', time = 957105, value = 1000, from = 'USD', quote = 'DOT')
```

## Sub Query

Sub Query takes a different approach.


Sub Query has a search feature to find projects for a specific chain you are interested.  `Acala` and `Karura` has many different projects, a short list of which can be found [here](https://acala.rogerjbos.com/about/).


```{r}

url <- 'https://api.subquery.network/sq/AcalaNetwork/karura-tokens'
query <- 'query { accountBalances (first: 6) { nodes { id accountId tokenId total } } }'
tmp <- get_query(url, query)
head(tmp)
```






## Polkaholic

Polkaholic provides an [API](https://docs.polkaholic.io/#introduction) for accessing their data.  You have to request a key [here](https://polkaholic.io/login).  I will show some examples of pulling data from the Polkaholic API below, but if you have any questions, the best place to ask them is in their [maxtrix site](https://app.element.io/#/room/#subscan:matrix.org).

Polkaholic currently covers 60 different chains, which you can view using the `get_polkaholic_chains` function.  When interacting with their API, you can use either the `id` or the `chainID`.

```{r}
tmp <- get_polkaholic_chains()
head(tmp)
```
As an example, we will pull up the first five dex Swap transaction for the Karura parachain between July 1st and July 2nd.

```{r}
tmp <- get_polkaholic_events(chain = "karura", module = "dex", call = 'Swap', startDate='2022-07-01', endDate='2022-07-02', nobs = 5)
head(tmp)
```

In addition to specifying the `startDate` and `endDate`, you can also specify the `startBlock` and `endBlock`.

```{r}
tmp <- get_polkaholic_events(chain = "karura", module = "dex", call = 'Swap', startBlock=1000000, endBlock=1000015, nobs = 5)
head(tmp)
```

Polkaholic does not use pagination, but you can request up to 100,000 rows at a time using the `nobs` parameter.  If you need more than that, you will have to use `startDate` and `endDate` (or `startblock` and `endBlock`) to make multiple calls and piece the data together yourself.

Notice that Polkaholic does not return the transaction details (the `params` object from Subscan), instead, you have to use the `extrinsic_hash` and manually retrieve the details using the `get_polkaholic_transaction` function.


```{r}
tmp <- get_polkaholic_transaction(TxHash = '0x079192270cfd80cebf03c54eb59dd48528b6e1506a697ed6c11a832deb193bd4')
head(tmp)
```

If you have a transaction hash and all you need to know if the associated block number, you can use the `get_polkaholic_hash` function for that.

```{r}
get_polkaholic_hash(TxHash = '0x079192270cfd80cebf03c54eb59dd48528b6e1506a697ed6c11a832deb193bd4')
```

To make this easier, I implemented the `extract_polkaholic_events` function to query, extract, and aggregate the data, but so far this has only been implemented for dex Swaps, so it is pretty limited.  Again, looking at the code it should be easy to see how to extend it for more modules.

```{r}
tmp1 <- get_polkaholic_events(chain = "karura", module = "dex", call = 'Swap', startBlock=1, endBlock=2208550, nobs = 10)
tmp2 <- extract_polkaholic_events(tmp1)
head(tmp2)
```

Finally, if you have a transaction hash and all you need to know if the associated block number, you can use the `get_polkaholic_hash` function for that.

```{r}
get_polkaholic_hash(TxHash = '0x079192270cfd80cebf03c54eb59dd48528b6e1506a697ed6c11a832deb193bd4')
```

## Python Substrate Interface

Most Web3 tools are written in Javascript and / or Typescript, but the [Polkascan](https://explorer.polkascan.io/) team created a python library to interact with substrate and it works really well.  I will show some examples below, but more documentation on it can be found [here](https://polkascan.github.io/py-substrate-interface/).  If you have any questions on using it, the best place to ask in the the [Substrate Stack Exchange](https://substrate.stackexchange.com/).

```{r, results='asis'}
knitr::kable(head(mtcars, 10))
```

